# opencv笔记（题目思路在最后，前面全是笔记

## opencv简介
1. 定义
   - 一个开源的计算机视觉与机器学习软件库
2. 使用
   - 在编写代码时用`#include <opencv4/lib_name>`从opencv库中引入<opencv4/lin_name>的头文件
   - 使用`using namespace cv`来使用命名空间 cv::function() 
3. 用处
   - 图像读取与显示
   - 图像处理与增强
   - 特征检测与描述
   - 对象检测与识别
   - 图像分割与轮廓提取
   - 摄像头捕捉与视频处理
   - 机器人学习与深度学习
   - 相机标定与立体视觉

## 通道
1. 定义(一个通道只能描述一个维度的信息)
   - 图像数据中包含的不同信息的分离部分，每个色彩通道都包含了图像中特定颜色分量的强度或亮度。通过操作色彩通道，可以对图像进行各种处理，例如调整色彩平衡、增加对比度等
   - 在灰度图像中，只有一个通道，代表图像的亮度信息。而在彩色图像中，通常会有多个通道，每个通道包含了特定颜色分量的信息。对于深度图像（如深度相机捕获的图像），可能会有额外的深度通道用于表示场景中物体的距离信息

## 像素
1. 定义
   - 数字图像的最基本构成单元。每一个像素都代表了图像中的一个小区域，并且包含了该区域内的颜色和亮度信息。
2. 组成
   - 灰度图像中每个像素都代表了一个特定位置上的灰度值(0~255)。灰度值反映了图像中该位置的亮度或灰度级别，其中 0 代表黑色，255 代表白色，灰度值越大，则该位置的亮度越高。ps. 灰度值应为整数
   - 彩色图像中一个像素通常由红、绿、蓝三个颜色通道的数值组成，用来描述该点的颜色。这些数值可以是整数或浮点数，取决于图像的数字表示精度。
   
## 位深
1. 定义
   - 储存一个像素所用的位(bit)数被称为位深
2. 特点
   - 储存一个像素所用的位数越多，色彩信息或者说图像信息越丰富
   - 特殊的，如果只用一位来表示一个像素，则只会有黑和白(0或1)

## 图像的频域表示
1. 将图像的各通道分布函数经离散傅里叶变换可得到图像的频率分布函数，变成频率分布函数后就可以用各种信号处理技术对它进行处理

## 数字图像的矩阵表示

### 理解
1. 数字图像可以被看作一个二维矩阵，其中每个元素代表了图像上对应位置的像素值。这种矩阵表示方式可以方便地用来进行各种图像处理操作。
### 分类与实例(一般来说，数字图像可分为灰度图像与彩色图像，它们在矩阵表示上略有不同)
1. 灰度图像
   - 对于灰度图像，其矩阵表示非常简单，每个元素都表示了图像对应位置的灰度值。这通常是一个二维矩阵，每个元素的取值范围通常是0到255，代表了黑到白的不同灰度级别
   - 例子 [120, 125, 130] [110, 115, 120] [100, 105, 110]
2. 彩色图像
   - 彩色图像通常使用RGB（红绿蓝）颜色模型来表示。在矩阵表示中，彩色图像通常被表示为三个独立的二维矩阵，分别对应红色通道、绿色通道和蓝色通道。每个通道的元素代表了图像在对应位置的颜色强度
   - 例子 红色通道：[ [200, 50, 75], [190, 45, 70], [180, 40, 65] ]  绿色通道：[ [100, 150, 200], [95, 145, 195], [90, 140, 190] ] 蓝色通道：[ [50, 100, 150], [45, 95, 145], [40, 90, 140] ]
## 了解RGB24
1. 定义
   - RGB24（也叫RGB888）是一种常见的图像格式，图像的每个像素在内存的连续位置中包含一个字节，每个像素使用24位（红、绿、蓝个8位）来表示颜色信息
2. 特点
   - RGB24格式中，每个像素由三个通道组成：红色、绿色、蓝色。每个通道都有8位，因此可以表示256个不同的亮度级别(0~255)。通过不同亮度级别的红、绿、蓝的组合，可以得到不同的颜色
3. 格式
low memory address    ---->      high memory address
|pixel|pixel|pixel|pixel|pixel|pixel|pixel|pixel|...
|-----|-----|-----|-----|-----|-----|-----|-----|...
|B|G|R|B|G|R|B|G|R|B|G|R|B|G|R|B|G|R|B|G|R|B|G|R|...

## 色彩空间(一种用来描述颜色的数学模型，将颜色在三维空间中进行表示)

### 一些常见色彩空间

#### RGB色彩空间
1. 定义
   - RGB色彩空间是由红色（R）、绿色（G）和蓝色（B）三个颜色通道组成的。在计算机图形学中，图像通常使用RGB色彩空间来表示颜色
2. 属性
   - 附加色彩空间，由三种颜色的值的线性组合得到
   - 这三个通道与照射到表面的光量有关。这意味着RGB色彩空间中每个通道的数值与三种颜色的光的强度相关联
3. 缺陷
   - 明显的感知不均匀，对人来说不形象
   - 色度（颜色相关信息）与亮度（亮度相关信息）的数据容易混合，受亮度影响大

#### HSV色彩空间
1. 组成
   - H 色相（表示颜色在光谱中的位置，0~360度。色环环绕呈圆形，0度和360度为红色，120度为绿色，240度是蓝色）
   - S 饱和度 （表示颜色的纯度或鲜艳程度，0~100%，0表示完全无色彩，100%表示纯色）
   - V 亮度（明暗程度，0~100%)
2. 属性
   - 受亮度影响不大，能设立一套特定的阀值来提取图中的颜色而不受亮度干扰
   - 设备相关，易受设备差异的影响
   - 只用一个通道来描述颜色(H)，使指定颜色变得非常直观

#### LAB色彩空间
1. 组成OpenCV_test sensor_msgs cv_bridge roscpp std_msgs image_transport
   - L 亮度（光的强度，仅对亮度编码，与颜色无关。用于控制图像的明暗度）(0~100; 0代表黑色，100代表白色)
   - a 颜色分量，范围由绿色到红色(-128~127; 负值表示绿色，正值表示红色)
   - b 颜色分量，范围由蓝色到黄色(-128~127; 负值表示蓝色，正值表示黄色)
2. 属性
   - 感知均匀，近似于我们人类感知颜色的方式
   - 独立于设备，这意味着，即使在不同的摄像头或显示设备中，LAB颜色空间的颜色保持一致，不受设备差异的影响
   - 由于前两种性质，而被广泛地应用于Adobe Photoshop等图像处理软件中
   - 通过复杂的变换方程与RGB颜色空间相关
   - 将色度与亮度分离到不同通道里

#### YCrCb色彩空间
1. 组成
   - Y 伽马矫正后由RGB获得的亮度分量(0~255)
   - Cr=R-Y (红色分量与亮度分量Luma的距离）
   - Cb=B-Y (蓝色分量与亮度分量Luma的距离）
2. 属性
   - 将亮度与色度分离到不同的通道里
   - 设备相关，即易受设备差异的影响
### 使用颜色空间进行分割的方法
1. 步骤
   - 获取特定颜色的颜色值
   - 应用阀值进行分割

## 一些函数/操作

### 读取图像 cv2.imread(img_path,flag)
1. image_path
   - 图像的路径。即使路径错误，在运行时也不会报错，但是打印返回的图片对象为None
2. flag
   - cv2.IMREAD_COLOR,读取彩色图像，图片的透明性会被忽略，为默认参数，也可以传入参数 1
   - cv2.IMREAD_GRAYSCALE,按灰度模式读取图像，也可以传入参数 0
   - cv2.IMREAD_UNCHANGED,读取图像，包括其alpha通道（透明度有关），也可以传入参数 -1
   
### 保存（写入）图像 cv2.imwrite(img_path_name,img)
1. img_path_name
   - 保存的文件的路径的名字
2. img
   - 文件对象

### 转颜色空间
`cvtColor(origin_img,dst_img,COLOR_当前颜色空间2目标颜色空间)`
 
### HSV颜色提取
1. 步骤 
   - 读取的图像基本为BGR格式，需要先使用`cvColor(imgOriginal, imgHSV, COLOR_BGR2HSV)`转为HSV格式
   - 再使用`inRange(imgHSV, Scalar(iLowH, iLowS, iLowV), Scalar(iHighH, iHighS, iHighV), imgThresholded)`对满足阀值约束的像素进行保留，达到提取特定颜色的目的**iHigh参数:参数的最大阀值，iLow参数:参数的最小阀值**
   
### 图像性质
1. img.shape (图象形状）
2. img.size (图像大小,所占字节)
3. img.dtype (图像储存格式)

### 访问像素
1. at()方法
   - at() 方法用于访问图像或矩阵中特定像素的值。它是一个模板函数，可以根据图像或矩阵的数据类型返回相应的像素值
   - 函数原型：template<typename _Tp> _Tp& cv::Mat::at(int row, int col); 

     **_Tp:表示像素值的数据类型**

     **row:像素所在的行索引(坐标)**

     **col:像素所在的列索引(坐标)**
   - 示例：cv::Mat image = cv::imread("image.jpg"); cv::Vec3b pixel = image.at<cv::Vec3b>(row, col);获取了图像中指定位置的像素值，并储存在一个cv::Vec3b(指有3个通道的像素)类型的变量中
2. ptr()方法
   -  ptr() 方法用于获取指向图像或矩阵特定行的指针。这个方法返回一个指针，可以通过对指针进行偏移来访问特定列的像素值
   - 函数原型：template<typename _Tp> _Tp* cv::Mat::ptr(int row); 

     **_Tp：表示像素值的数据类型**

     **row：要获取指针的行索引**
   - 示例：cv::Mat image = cv::imread("image.jpg"); cv::Vec3b* row_ptr = image.ptr<cv::Vec3b>(row); cv::Vec3b pixel = row_ptr[col];使用 ptr() 方法获取指向图像指定行的指针。然后，它通过对指针进行偏移来访问特定列的像素值
3. 这两种方法都可以用于访问和修改像素值。但需要注意的是，使用这些方法时要确保索引不超出图像或矩阵的范围，以避免访问无效的内存位置

### Mat函数

#### `Mat()` 
1. 用处
   - 定义一个矩阵、图像

#### `Mat(int rows,int cols,int type)`和`Mat(Size size,int type)`
1. 参数
 **rows** 二维矩阵的行数
 
 **cols** 二维矩阵的列数
 
 **size** 二维矩阵的大小格式为`Size(cols,rows)`，在Size构造函数中行列反排
 
 **type** 数组（矩阵）类型
   - 单通道灰度图像：使用单个矩阵表示，通常为8位无符号整型（CV_8U）或32位浮点型（CV_32F）。
   - 三通道彩色图像（BGR格式）：使用三个矩阵分别表示蓝色通道、绿色通道和红色通道，通常为8位无符号整型（CV_8UC3）或32位浮点型（CV_32FC3）
   - 四通道图像（BGRA格式）：使用四个矩阵分别表示蓝色通道、绿色通道、红色通道和透明度通道，通常为8位无符号整型（CV_8UC4）或32位浮点型（CV_32FC4）
   - 8位无符号整型(CV_8U)、8位有符号整型(CV_8S)、16位无符号整型(CV_16U)、16位有符号整型(CV_16S)、32位有符号整型(CV_32S)、32位浮点型(CV_32F)、64位浮点型(CV_64F)
2. 用处
   - 用于生成一个自定义大小的矩阵、图像（例 `Mat(400,600,CV_8UC3)`创建了一个400行，600列的8位三通道彩色图像，`Mat((600,400),CV_8U)`创建了一个600列，400行的单通道矩阵（图像））

#### `Mat(int rows,int cols,int type,const Scalar &s)`和`Mat(Size size,int type,const Scalar &s)
1. 参数
   - rows 行数
   - cols 列数
   - size Size(cols,rows),指定了矩阵的大小
   - type 矩阵类型
   - s Scalar类型的对象，用于指定矩阵的初始值（Scalar：标量）
2. 用处
   - 用于创建自定义大小的矩阵并初始化（例 `Mat(3,3,CV_8U,(0,0,225))`和`Mat((3,3),CV_8U,(0,0,225))`创建了一个3*3的初始值为(0,0,255)的矩阵） 

#### `Mat_(const Mat_ &m)`
1. 这个构造函数创建了一个新的Mat_对象，并从现有的Mat_对象进行初始化（即拷贝了&m这个矩阵）。这意味着，新对象与现有对象共享相同的数据（即底层存储器），并且在修改任一对象时都会影响另一个对象。这个构造函数通常用于创建指向已存在的数据的视图或副本。

#### `Mat(const Mat &m)`
1. 这个构造函数创建了一个新的Mat对象，并从现有的Mat对象进行初始化。与Mat_不同，新对象是一个特化版本Mat_<double>，因此可以使用Mat类的所有方法和操作。与Mat_构造函数一样，这个构造函数也会共享相同的数据（即底层存储器），并且在修改任一对象时都会影响另一个对象。这个构造函数通常用于创建指向已存在的数据的视图或副本，并用于某些特定的算法或操作。

### 测量时间
1. `cv::getTickCount()`：这个函数返回从某个特定事件开始（通常是系统启动时）到当前的时钟周期数。它通常用于测量代码段的执行时间
2. `cv::getTickFrequency()`：这个函数返回时钟频率，即每秒的时钟周期数。通过将调用cv::getTickCount()返回的时钟周期数除以cv::getTickFrequency()，可以得到经过的时间（单位为秒）

## 题目思路

### 第一题
1. 用`Mat(cols,rows,type)`先生成一个8位的400*600的单通道矩阵
2. 用两层for循环遍历每一个像素
3. 因为渐变方向是横向的，故依据所处列与总列数作比以确定当前像素所处位置
4. 依据前面的计算得到的位置计算出现在位置的灰度值
5. 利用`at()`来一个一个的改变像素的灰度值
6. 利用`imshow(window_name,image_name)`显示图像

### 第二题
1. 用`Mat(int rows,int cols,int type,const Scalar &s)`来生成一个400*600的8位3通道矩阵并对它进行初始化
2. 用两层for循环来遍历每一个位置
3. 利用`at()`设置每个通道的值，将目标颜色通道设置为非零，其余两个设置为0（ps我在源码备注中写的是RGB颜色空间，这里实际应为BGR）
4. 利用`imshow（）`显示图像


## 第三题和第四题
1. 绿色勾
   - 首先利用`imread()`读取要切割的原图像
   - 然后依据BGR颜色空间中绿色的范围设置阀值
   - 接着定义掩码并利用`imRange(src_img,lowerb,upperb,dst_img)`对原图像进行处理，切割出掩码图形
   - 再转成BGR用for嵌套遍历每一个位置把颜色复原
   - 最后显示目标图像
2. 棕色叉
   - 利用`imread()`读取原图像
   - 因为在BGR里面不好找棕色的阀值，所以县把原图像变为利用HSV颜色空间的图像
   - 接着设置棕色由BGR映射到HSV后的阀值，确定范围
   - 定义掩码，用`imRange(src_img,lowerb,upperb,dst_img)`对原图像处理，切割出掩码
   - 再转成BGR用for嵌套遍历每一个位置把颜色复原（本来想先转HSV处理完再转BGR的，但是编译过不了，在cvtColor报错，所以就直接转BGR了，效果会差一点）
   - 显示目标图像
